//**************************************************************************************************
//                               LCD.c
// 
//	Управление жидкокристаллическим индикатором (ЖКИ) MT-16SD2: 
//  - вариант подключения 4-х битный интерфейс 
//  
//  Created: 08.08.2016
//  Автор: Иванов
// 
//**************************************************************************************************

//**************************************************************************************************
// ЗАГОЛОВКИ
//**************************************************************************************************
#include	"main.h"
#include	"LCD.h"
#include	<stdio.h>
//**************************************************************************************************
void LCDDataStrobe(void);
void LCDDataStrobe2(void);
void LCDClear(void);
void LCDClear2(void); 

//**************************************************************************************************
//	LCDSetup - модуль начальных установок ЖКИ: 4-х битный интерфейс
//	Входные параметры:  нет
//	Выходные параметры: нет
//**************************************************************************************************
static FILE mystdout;
void LCDSetup(void)
{
	// задержка после подачи питания 
	_delay_ms(TIME_POWER_ON);
	
	// назначение выходами выводов порта управления контроллером LCD
	LCD_DDR_PORT = (LCD_DATA_MASK | LCD_CONTROL_MASK);
	// Назначаем выходом 8 пин порта - управление включением минуса подсветки LCD 
	LIGHT_DDR_PORT |= LIGHT_LED_MINUS_MASK;		
	// установка в "0" выводов порта управления и данных контроллером LCD
	LCD_PORT = 0;
	
//--------------------------------------------------------------------------------------------------
// Установка 8-и битного интерфейса
//--------------------------------------------------------------------------------------------------
//	// подготовка команды "Function Set"
//	LCD_PORT &= (~(1 << A0)) & (~(1 << RW));
//	LCD_PORT &= (~(LCD_DATA_MASK));
//	LCD_PORT |= LCD_CMD_8_BIT;
//	
//	// задержка на время выполнения команды
//	_delay_us(TIME_CMD_ALL);
//	
//	// вызов модуля стробирования данных 
//	LCDDataStrobe();
//	LCDDataStrobe();
//	LCDDataStrobe();		
//	
//--------------------------------------------------------------------------------------------------
// Установка 4-х битного интерфейса
//--------------------------------------------------------------------------------------------------
	LCD_PORT &= (~(LCD_DATA_MASK));			// Начальная установка индикатора
	
	LCD_PORT |= LCD_COD_INI1_4BIT;			// A0, R/W, DB7, DB6, DB5, DB4 = 000011
	LCDDataStrobe();						// Cтробирование данных
	_delay_us(TIME_DELAY_INI_LCD);			// Задержка 40 мкс
	
	LCDDataStrobe();						// Cтробирование данных
	_delay_us(TIME_DELAY_INI_LCD);			// Задержка 40 мкс
	
	LCDDataStrobe();						// Cтробирование данных
	_delay_us(TIME_DELAY_INI_LCD);			// Задержка 40 мкс
	
//--------------------------------------------------------------------------------------------------
// Завершение настройки ЖКИ
//--------------------------------------------------------------------------------------------------
	// "Function Set" - установка разрядности интерфейса (==4x) и страницы знакогенератора (==0)
	LCDSendCMD(LCD_CMD_FUNCTION_SET);
	
	// "Display ON/OFF control"  команда выключения LCD, курсора нет, ничего не мигает
	LCDSendCMD(LCD_CMD_OFF_OFF_OFF);	
	
	// вызов модуля очистки экрана LCD
	LCDClear(); 
	
	// "Entry mode set" команда установки направления сдвига курсора и разрешения сдвига дисплея
	LCDSendCMD(LCD_CMD_ENTRY_MODE_RIGHT);
	
	// "Display ON/OFF control"  команда включения LCD, курсора нет, ничего не мигает
	LCDSendCMD(LCD_CMD_ON_OFF_OFF);	
	
	stdout = &mystdout;
}

//**************************************************************************************************
//	LCDSetup2 - модуль начальных установок ЖКИ: 4-х битный интерфейс
//	Входные параметры:  нет
//	Выходные параметры: нет
//	Особенность реализации в том, что управление ЖКИ осуществляется несколькими портами 
//**************************************************************************************************
void LCDSetup2(void)
{
	// задержка после подачи питания
	_delay_ms(TIME_POWER_ON);
	
	// назначение выходами выводов порта управления контроллером LCD
	DDRG |= (1 << DDG0) | (1 << DDG1) | (1 << DDG2) | (1 << DDG3);		// DB4...DB7	- на PORTG (PG0...PG3)
	DDRA |= (1 << DDA6) | (1 << DDA7);									// E и R/W		- на PORTA (PA6 и PA7)
	DDRC |= (1 << DDC7);												// A0			- на PORTC (PC7)
	
	// Назначаем выходом PG4 пин порта - управление включением минуса подсветки LCD
	DDRG |= (1 << DDG4);
	
	// установка в "0" выводов портов управления и данных контроллером LCD
	PORTG = 0;
	PORTA = 0;
	PORTC = 0;

//--------------------------------------------------------------------------------------------------
// Установка 4-х битного интерфейса
//--------------------------------------------------------------------------------------------------
	//LCD_PORT &= (~(LCD_DATA_MASK));			// Начальная установка индикатора ЗАЧЕМ ?
												// A0, R/W, DB7, DB6, DB5, DB4 = 000011
	PORTG |= (1 << PORTG0) | (1 << PORTG1);	
	PORTA &= ~(1 << PORTA6) & (1 << RW);
	PORTC &= ~(1 << A0);
	LCDDataStrobe2();							// Cтробирование данных
	_delay_us(TIME_DELAY_INI_LCD);				// Задержка 40 мкс
	
	LCDDataStrobe2();							// Cтробирование данных
	_delay_us(TIME_DELAY_INI_LCD);				// Задержка 40 мкс
	
	LCDDataStrobe2();							// Cтробирование данных
	_delay_us(TIME_DELAY_INI_LCD);				// Задержка 40 мкс
	
//--------------------------------------------------------------------------------------------------
// Завершение настройки ЖКИ
//--------------------------------------------------------------------------------------------------
	// "Function Set" - установка разрядности интерфейса (==4x) и страницы знакогенератора (==0)
	LCDSendCMD2(LCD_CMD_FUNCTION_SET);
	
	// "Display ON/OFF control"  команда выключения LCD, курсора нет, ничего не мигает
	LCDSendCMD2(LCD_CMD_OFF_OFF_OFF);
	
	// вызов модуля очистки экрана LCD
	LCDClear2();
	
	// "Entry mode set" команда установки направления сдвига курсора и разрешения сдвига дисплея
	LCDSendCMD2(LCD_CMD_ENTRY_MODE_RIGHT);
	
	// "Display ON/OFF control"  команда включения LCD, курсора нет, ничего не мигает
	LCDSendCMD2(LCD_CMD_ON_OFF_OFF);	
	
	stdout = &mystdout;
}

//**************************************************************************************************
//	LCDDataStrobe - модуль стробирования данных
//	Входные параметры:  нет
//	Выходные параметры: нет
//**************************************************************************************************
void LCDDataStrobe(void)
{	
	// установка высокого уровня ("1") строба данных
	LCD_PORT |= (1 << E);
	
	// задержка на время стробирования данных
	_delay_us(TIME_DATA_STROBE);

	// установка низкого уровня ("0") строба данных
	LCD_PORT &= (~(1 << E));
	
	// задержка на время стробирования данных
	_delay_us(TIME_DATA_STROBE);
}

//**************************************************************************************************
//	LCDDataStrobe2 - модуль стробирования данных
//	Входные параметры:  нет
//	Выходные параметры: нет
//**************************************************************************************************
void LCDDataStrobe2(void)
{	
	// установка высокого уровня ("1") строба данных
	PORTA |= (1 << E);
	
	// задержка на время стробирования данных
	_delay_us(TIME_DATA_STROBE);

	// установка низкого уровня ("0") строба данных
	PORTA &= (~(1 << E));
	
	// задержка на время стробирования данных
	_delay_us(TIME_DATA_STROBE);
}

//**************************************************************************************************
//	LCDReady - модуль проверки готовности ЖКИ выполнить очередную команду
//	Входные параметры:  нет
//	Выходные параметры: нет
//**************************************************************************************************
void LCDReady(void)
{
	// назначение входами выводов шины данных порта управления (разряды PA3..PA6)
	LCD_DDR_PORT &= (~LCD_DATA_MASK);

	// подготовка управляющих разрядов (A0 и R/W) команды "Read BUSY flag and Address"
	LCD_PORT &= (~(1 << A0));
	LCD_PORT |= (1 << RW);

	// задержка на время выполнения команды
	_delay_us(TIME_CMD_ALL);
	
	// установка высокого уровня ("1") строба данных
	LCD_PORT |= (1 << E);

	// задержка на время стробирования данных
	_delay_us(TIME_DATA_STROBE);
	
	// цикл ожидания сброса флага занятости (BS)
	while ((LCD_PIN_PORT & (1 << BS)) != 0);

	// установка низкого уровня ("0") строба данных
	LCD_PORT &= (~(1 << E));
	
	// задержка на время стробирования данных
	_delay_us(TIME_DATA_STROBE);

	// вызов модуля стробирования данных
	LCDDataStrobe();
}

//**************************************************************************************************
//	LCDReady2 - модуль проверки готовности ЖКИ выполнить очередную команду
//	Входные параметры:  нет
//	Выходные параметры: нет
//**************************************************************************************************
void LCDReady2(void)
{
	// назначение входами выводов шины данных порта управления (разряды PG0...PG3)	
	DDRG &= ~(1 << DDG0) & ~(1 << DDG1) & ~(1 << DDG2) & ~(1 << DDG3);		// DB4...DB7	- на PORTG (PG0...PG3)
	
	// подготовка управляющих разрядов (A0 и R/W) команды "Read BUSY flag and Address"
	PORTC &= ~(1 << A0);
	PORTA |= (1 << RW);
	
	// задержка на время выполнения команды
	_delay_us(TIME_CMD_ALL);
	
	// установка высокого уровня ("1") строба данных
	PORTA |= (1 << E);
	
	// задержка на время стробирования данных
	_delay_us(TIME_DATA_STROBE);
	
	// цикл ожидания сброса флага занятости (BS)
	//while ((LCD_PIN_PORT & (1 << BS)) != 0);
	while ((PING & (1 << BS)) != 0);
	
	// установка низкого уровня ("0") строба данных
	PORTA &= (~(1 << E));
	
	// задержка на время стробирования данных
	_delay_us(TIME_DATA_STROBE);

	// вызов модуля стробирования данных
	LCDDataStrobe2();
}

//**************************************************************************************************
//	LCDSendByte - модуль посылки байта: данных или команды управления
//	Входные параметры:
//	Byte - передаваемый байт 
//	RS   - выбор между передачей данных или команды управления (RS - Register Select)
//	- TRUE:  передача данных ("1")
//	- FALSE: передача команды управления ("0") 
//	Выходные параметры: нет
//**************************************************************************************************
void LCDSendByte(uint8_t Byte, uint8_t RS)
{
	// вызов модуля проверки готовности ЖКИ выполнить очередную команду
	LCDReady();
	
//--------------------------------------------------------------------------------------------------
// Подготовка и выполнение заданной команды 
//--------------------------------------------------------------------------------------------------
	// назначение выходами выводов шины данных порта управления (биты PA3..PA6)
	LCD_DDR_PORT |= LCD_DATA_MASK;

	// подготовка управляющих битов команды (A0 и R/W) 
	if (RS)
	// передача данных
	{
		LCD_PORT |= (1 << A0);
	}
	else
	// передача команды
	{
		LCD_PORT &= (~(1 << A0));
	}
	LCD_PORT &= (~(1 << RW));

//--------------------------------------------------------------------------------------------------
// Посылка старших 4-х разрядов данных
//--------------------------------------------------------------------------------------------------
	// подготовка данных
	LCD_PORT &= (~LCD_DATA_MASK);
	LCD_PORT |= ( ( Byte >> 1 ) & LCD_DATA_MASK );
	
	// задержка на время выполнения команды
	_delay_us(TIME_CMD_ALL);

	// вызов модуля стробирования данных
	LCDDataStrobe();

//--------------------------------------------------------------------------------------------------
// Посылка младших 4-х разрядов данных
//--------------------------------------------------------------------------------------------------
	// подготовка данных
	LCD_PORT &= (~LCD_DATA_MASK);
	LCD_PORT |= ( ( Byte << 3 ) & LCD_DATA_MASK );
	
	// задержка на время выполнения команды
	_delay_us(TIME_CMD_ALL);

	// вызов модуля стробирования данных
	LCDDataStrobe();
}	

//**************************************************************************************************
//	LCDSendByte2 - модуль посылки байта: данных или команды управления
//	Входные параметры:
//	Byte - передаваемый байт
//	RS   - выбор между передачей данных или команды управления (RS - Register Select)
//	- TRUE:  передача данных ("1")
//	- FALSE: передача команды управления ("0")
//	Выходные параметры: нет
void LCDSendByte2(uint8_t Byte, uint8_t RS)
{
	// вызов модуля проверки готовности ЖКИ выполнить очередную команду
	LCDReady2();	
	//uint8_t a = Byte;
//--------------------------------------------------------------------------------------------------
// Подготовка и выполнение заданной команды
//--------------------------------------------------------------------------------------------------	

	// назначение выходами выводов шины данных порта управления (биты PA3..PA6)
	DDRG |= (1 << DDG0) | (1 << DDG1) | (1 << DDG2) | (1 << DDG3);		// DB4...DB7	- на PORTG (PG0...PG3)
	
	// подготовка управляющих битов команды (A0 и R/W) 
	if (RS)
	// передача данных
	{
		PORTC |= (1 << A0);
	}
	else
	// передача команды
	{
		PORTC &= (~(1 << A0));
	}
	PORTA &= (~(1 << RW));
	
	//--------------------------------------------------------------------------------------------------
	// Посылка старших 4-х разрядов данных
	//--------------------------------------------------------------------------------------------------
	// подготовка данных
	PORTG &= ~(1 << PORTG0) & ~(1 << PORTG1) & ~(1 << PORTG2) & ~(1 << PORTG3);
	PORTG |= ( ( Byte >> 4 ) & LCD_DATA_MASK );

	// задержка на время выполнения команды
	_delay_us(TIME_CMD_ALL);

	// вызов модуля стробирования данных
	LCDDataStrobe2();
	
	//--------------------------------------------------------------------------------------------------
	// Посылка младших 4-х разрядов данных
	//--------------------------------------------------------------------------------------------------
	// подготовка данных
	PORTG &= (~LCD_DATA_MASK);
	PORTG |= (Byte & LCD_DATA_MASK);
	//LCD_PORT |= ( ( Byte << 3 ) & LCD_DATA_MASK );

	// задержка на время выполнения команды
	_delay_us(TIME_CMD_ALL);

	// вызов модуля стробирования данных
	LCDDataStrobe2();
}

//**************************************************************************************************
//* LCDClear - модуль очистки экрана ЖКИ
//* Входные параметры:  нет
//* Выходные параметры: нет
//**************************************************************************************************
void LCDClear()
{
	// посылка команды "Clear Display"
	LCDSendCMD(LCD_CMD_CLEAR_DISPLAY);
	
	// задержка на время выполнения команды "Clear Display"
	_delay_ms(TIME_CMD_CLEAR_DISPLAY);	 
}

//**************************************************************************************************
//* LCDClear2 - модуль очистки экрана ЖКИ
//* Входные параметры:  нет
//* Выходные параметры: нет
//**************************************************************************************************
void LCDClear2()
{
	// посылка команды "Clear Display"
	LCDSendCMD2(LCD_CMD_CLEAR_DISPLAY);
	
	// задержка на время выполнения команды "Clear Display"
	_delay_ms(TIME_CMD_CLEAR_DISPLAY);	 
}
//----------------------------------------/ FUNCTION /----------------------------------------------
// void LCDClearLine0();
//
//  Очистить первую строку экрана
//
//--------------------------------------------------------------------------------------------------
void LCDClearLine0()
{
	uint8_t i;
	
	// Устанавливаем курсор в начальную позицию
	LCDSendCMD(LCD_CMD_ADDRESS_LINE1); 
	// посылка строку символов 'пробел'
	for( i = 0; i < 16; i++ )	LCDSendData(' ');
}	
//**************************************************************************************************
// LCD LightControl - модуль управления яркостью подсветки экрана ЖКИ
// Входные параметры:
//	display_light_code: код яркости подсветки
//		
// Выходные параметры: нет
//**************************************************************************************************
/*void LCDLightControl()
{
	// вызов модуля останова "Сторожевой собаки 0"
	Timer0Stop();
	
	// выбор нового значения яркости подсветки
	switch (DisplayLightCode)
	{
		case DLC25:							// 25% яркости (слабая яркость)
		case DLC50:							// 50% яркости (средняя яркость)
		case DLC75:							// 75% яркости (большая яркость)								
				Timer0Start();
		break;
		case DLC100:																				
				LCD_POWER_ON;				// 100% яркости (полная яркость)
		break;
		case DLC0:	
		default:																					
				LCD_POWER_OFF;				// 0% яркости (подсветка выключена)
		break;
	}
}*/
//----------------------------------------/ FUNCTION /----------------------------------------------
// void gotoxy( uint8_t x, uint8_t y );
//
//  Установить курсор в координату (X,Y)
//
//--------------------------------------------------------------------------------------------------
void gotoxy( uint8_t x, uint8_t y )
{
	//uint8_t i = 0;
	y &= 0x01;
	x &= 0x0F;
	
	// Устанавливаем курсор в заданную позицию
	LCDSendCMD(((y * 0x40) + x) | LCD_CMD_ADDRESS_LINE1);
}
//----------------------------------------/ FUNCTION /----------------------------------------------
// void putsxy( uint8_t x, uint8_t y, char *string );
//
//  Вывести строку текста string, начиная с координаты (X,Y)
// 
//--------------------------------------------------------------------------------------------------
void putsxy( uint8_t x, uint8_t y, char *string )
{
	uint8_t i = 0;
	y &= 0x01;
	x &= 0x0F;
	
	// Устанавливаем курсор в заданную позицию
	LCDSendCMD(((y * 0x40) + x) | LCD_CMD_ADDRESS_LINE1);
	// посылка строки символов
	while(string[i])
	LCDSendData(string[i++]);			
}

//----------------------------------------/ FUNCTION /----------------------------------------------
// void putsxy( uint8_t x, uint8_t y, char *string );
//
//  Вывести строку текста string, начиная с координаты (X,Y)
//
//--------------------------------------------------------------------------------------------------
void putsxy2( uint8_t x, uint8_t y, char *string )
{
	uint8_t i = 0;
//	y &= 0x01;
//	x &= 0x0F;
	
	// Устанавливаем курсор в заданную позицию
	//LCDSendCMD2(((y * 0x40) + x) | LCD_CMD_ADDRESS_LINE1);
	LCDSendCMD2((y + x) | LCD_CMD_ADDRESS_LINE1);
	// посылка строки символов
	while(string[i])
		LCDSendData2(string[i++]);	
}


//----------------------------------------/ FUNCTION /----------------------------------------------
// void putsxy( uint8_t x, uint8_t y, char *string );
//
//  Вывести строку текста string, начиная с координаты (X,Y)
//
//--------------------------------------------------------------------------------------------------
void clr( uint8_t x, uint8_t y, char *string )
{
	uint8_t i = 0;
	y &= 0x01;
	x &= 0x0F;
	
	// Устанавливаем курсор в заданную позицию
	LCDSendCMD(((y * 0x40) + x) | LCD_CMD_ADDRESS_LINE1);
	// посылка строки символов
	while(string[i])
	LCDSendData(string[i++]);
}
//----------------------------------------/ FUNCTION /----------------------------------------------
// void putcxy( uint8_t x, uint8_t y, char ch );
//
//  Вывести символ ch в координате (X,Y)
//
//--------------------------------------------------------------------------------------------------
void putcxy( uint8_t x, uint8_t y, char ch )
{	
	// Устанавливаем курсор в заданную позицию
	LCDSendCMD(((y * 0x40) + x) | LCD_CMD_ADDRESS_LINE1);
	// посылка символа
	LCDSendData(ch);
}
//----------------------------------------/ FUNCTION /----------------------------------------------
// void putcxy( uint8_t x, uint8_t y, char ch );
//
//  Вывести символ ch в координате (X,Y)
//
//--------------------------------------------------------------------------------------------------
void putcxy2( uint8_t x, uint8_t y, char ch )
{
	// Устанавливаем курсор в заданную позицию
	LCDSendCMD2((y + x) | LCD_CMD_ADDRESS_LINE1);
	// посылка символа
	LCDSendData2(ch);
}
//----------------------------------------/ FUNCTION /----------------------------------------------
// void puts( char *string );
//
//  Вывести строку текста string в текущую позицию курсора
//
//--------------------------------------------------------------------------------------------------
int	puts(const char *__str)
{
	uint8_t i = 0;
	while(__str[i])
	LCDSendData(__str[i++]);
	return i;
}
//----------------------------------------/ FUNCTION /----------------------------------------------
// int my_putchar(char c, FILE *stream)
//
// Функция вывода символа для обеспечения работы функции printf
// 
// Для работы функции printf необходимо проинициализировать переменную stdout = &mystdout;
//--------------------------------------------------------------------------------------------------
// прототип функции вывода символа
static int my_putchar(char c, FILE *stream);

// определяем дескриптор для стандартного вывода
static FILE mystdout = FDEV_SETUP_STREAM
(
		my_putchar,			// функция вывода символа
		NULL,				// функция ввода символа, нам сейчас не нужна
		_FDEV_SETUP_WRITE	// флаги потока - только вывод
);
// функция вывода символа
static int my_putchar(char c, FILE *stream)
{
	LCDSendData(c);		
	return 0;
}
//-----------------------------------------/ END /--------------------------------------------------
